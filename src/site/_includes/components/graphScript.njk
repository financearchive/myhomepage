<script>
    // íŒŒì¼ëª…ìœ¼ë¡œ URL ì°¾ê¸° í•¨ìˆ˜ ì¶”ê°€
    function findNodeByTitle(nodes, title) {
        // ì •í™•í•œ ì œëª© ë§¤ì¹­
        let node = Object.values(nodes).find(n => n.title === title);
        if (node) return node;
        
        // ë¶€ë¶„ ë§¤ì¹­
        node = Object.values(nodes).find(n => 
            n.title.toLowerCase().includes(title.toLowerCase()) ||
            title.toLowerCase().includes(n.title.toLowerCase())
        );
        if (node) return node;
        
        // URL ê¸°ë°˜ ë§¤ì¹­
        const currentPath = decodeURI(window.location.pathname);
        node = Object.values(nodes).find(n => n.url === currentPath);
        if (node) return node;
        
        return null;
    }

    async function fetchGraphData() {
        const graphData = await fetch('/graph.json').then(res => res.json());
        const fullGraphData = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    }

    function getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
                if (keys.indexOf(key) != -1) {
                    if (!remaining[key].hide) {
                        existing[key] = remaining[key];
                    }
                } else {
                    acc[key] = remaining[key];
                }
                return acc;
            }, {});
        return existing, n_remaining;
    }

    function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            return null;
        }
        let remaining = JSON.parse(JSON.stringify(graphData.nodes));
        let links = JSON.parse(JSON.stringify(graphData.links));
        
        // ===== ðŸš€ IMPROVED: í˜„ìž¬ ë…¸ë“œ ì°¾ê¸° ë¡œì§ ê°œì„  =====
        let currentLink = decodeURI(window.location.pathname);
        let currentNode = remaining[currentLink];
        
        // í˜„ìž¬ URLë¡œ ì°¾ì§€ ëª»í•˜ë©´ ë‹¤ë¥¸ ë°©ë²•ë“¤ ì‹œë„
        if (!currentNode) {
            // íŽ˜ì´ì§€ ì œëª©ìœ¼ë¡œ ì°¾ê¸°
            const pageTitle = document.querySelector('h1')?.textContent || 
                             document.title.split(' | ')[0];
            
            if (pageTitle) {
                currentNode = findNodeByTitle(remaining, pageTitle);
            }
        }
        
        // ì—¬ì „ížˆ ëª» ì°¾ìœ¼ë©´ í™ˆ íŽ˜ì´ì§€ ì‚¬ìš©
        if (!currentNode) {
            currentNode = Object.values(remaining).find((v) => v.home);
            console.log(`âš ï¸  í˜„ìž¬ íŽ˜ì´ì§€ ë…¸ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ í™ˆíŽ˜ì´ì§€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤: ${currentLink}`);
        }
        
        if (!currentNode) {
            console.log(`âŒ ë…¸ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${currentLink}`);
            return { nodes: [], links: [] };
        }
        
        delete remaining[currentNode.url];
        if (!currentNode.home) {
            let home = Object.values(remaining).find((v) => v.home);
            if (home) {
                delete remaining[home.url];
            }
        }
        currentNode.current = true;
        let existing = {};
        existing[currentNode.url] = currentNode;
        
        for (let i = 0; i < depth; i++) {
            existing, remaining = getNextLevelNeighbours(existing, remaining);
        }
        
        nodes = Object.values(existing);
        if (!currentNode.home) {
            nodes = nodes.filter(n => !n.home);
        }
        let ids = nodes.map((n) => n.id);
        
        console.log(`âœ… ê·¸ëž˜í”„ ë Œë”ë§: ${nodes.length}ê°œ ë…¸ë“œ, í˜„ìž¬: ${currentNode.title}`);
        
        return {
            nodes,
            links: links.filter(function (con) {
                return ids.indexOf(con.target) > -1 && ids.indexOf(con.source) > -1;
            }),
        }
    }

    // ë‚˜ë¨¸ì§€ í•¨ìˆ˜ë“¤ì€ ë™ì¼...
    function getCssVar(variable) {return getComputedStyle(document.body).getPropertyValue(variable)}

    function htmlDecode(input) {
        var doc = new DOMParser().parseFromString(input, "text/html");
        return doc.documentElement.textContent;
    }

    function renderGraph(graphData, id, delay, fullScreen) {
        if (graphData == null) {
            return;
        }
        const el = document.getElementById(id);
        width = el.offsetWidth;
        height = el.offsetHeight;
        const highlightNodes = new Set();
        let hoverNode = null;
        const color = getCssVar("--graph-main");
        const mutedColor = getCssVar("--graph-muted");
        let Graph = ForceGraph()
        (el)
            .graphData(graphData)
            .nodeId('id')
            .nodeLabel('title')
            .linkSource('source')
            .linkTarget('target')
            .d3AlphaDecay(0.10)
            .width(width)
            .height(height)
            .linkDirectionalArrowLength(2)
            .linkDirectionalArrowRelPos(0.5)
            .autoPauseRedraw(false)
            .linkColor((link) => {
                if (hoverNode == null) {
                    return color;
                }
                if (link.source.id == hoverNode.id || link.target.id == hoverNode.id) {
                    return color;
                } else {
                    return mutedColor;
                }
                
            })
            .nodeCanvasObject((node, ctx) => {
                const numberOfNeighbours = (node.neighbors && node.neighbors.length) || 2;
                const nodeR = Math.min(7, Math.max(numberOfNeighbours / 2, 2));
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeR, 0, 2 * Math.PI, false);
                if (hoverNode == null) {
                    ctx.fillStyle = color;
                } else {
                    if (node == hoverNode || highlightNodes.has(node.url)) {
                        ctx.fillStyle = color;
                    } else {
                        ctx.fillStyle = mutedColor;
                    }
                }
                 
                ctx.fill();
                
                if (node.current) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeR + 1, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = color;
                    ctx.stroke();
                }

                const label = htmlDecode(node.title)
                const fontSize = 3.5;
                ctx.font = `${fontSize}px Sans-Serif`;

                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(label, node.x, node.y + nodeR + 2);
            })
            .onNodeClick(node => {
                window.location = node.url;
            })
            .onNodeHover(node => {
                highlightNodes.clear();
                if (node) {
                highlightNodes.add(node);
                node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                }
                hoverNode = node || null;
                
            });
            if (fullScreen || (delay != null && graphData.nodes.length > 4)) {
                setTimeout(() => {
                    Graph.zoomToFit(5, 75);
                }, delay || 200);
            }
        return Graph;
    }

    function renderLocalGraph(graphData, depth, fullScreen) {
        if (window.graph){
            window.graph._destructor();
        }
        const data = filterLocalGraphData(graphData, depth);
        return renderGraph(data, 'link-graph', null, fullScreen);
    }

    function filterFullGraphData(graphData) {
        if (graphData == null) {
            return null;
        }
        graphData = JSON.parse(JSON.stringify(graphData));
        const hiddens = Object.values(graphData.nodes).filter((n) => n.hide).map((n) => n.id);
        const data = {
            links: JSON.parse(JSON.stringify(graphData.links)).filter((l) => hiddens.indexOf(l.source) == -1 && hiddens.indexOf(l.target) == -1),
            nodes: [...Object.values(graphData.nodes).filter((n) => !n.hide)]
        }
        return data
    }

    function openFullGraph(fullGraphData) {
        lucide.createIcons({
                attrs: {
                    class: ["svg-icon"]
                }
            });
        return renderGraph(fullGraphData, "full-graph-container", 200, false);;
    }

    function closefullGraph(fullGraph) {
        if (fullGraph) {
            fullGraph._destructor();
        }
        return null;
    }
</script>
